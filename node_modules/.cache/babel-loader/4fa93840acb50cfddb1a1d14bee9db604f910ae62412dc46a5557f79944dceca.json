{"ast":null,"code":"'use strict';\n\nvar glob = require('glob');\nvar path = require('path');\nfunction trueCasePathSync(fsPath) {\n  // Normalize the path so as to resolve . and .. components.\n  // !! As of Node v4.1.1, a path starting with ../ is NOT resolved relative\n  // !! to the current dir, and glob.sync() below then fails.\n  // !! When in doubt, resolve with fs.realPathSync() *beforehand*.\n  var fsPathNormalized = path.normalize(fsPath);\n\n  // OSX: HFS+ stores filenames in NFD (decomposed normal form) Unicode format,\n  // so we must ensure that the input path is in that format first.\n  if (process.platform === 'darwin') fsPathNormalized = fsPathNormalized.normalize('NFD');\n\n  // !! Windows: Curiously, the drive component mustn't be part of a glob,\n  // !! otherwise glob.sync() will invariably match nothing.\n  // !! Thus, we remove the drive component and instead pass it in as the 'cwd'\n  // !! (working dir.) property below.\n  var pathRoot = path.parse(fsPathNormalized).root;\n  var noDrivePath = fsPathNormalized.slice(Math.max(pathRoot.length - 1, 0));\n\n  // Perform case-insensitive globbing (on Windows, relative to the drive /\n  // network share) and return the 1st match, if any.\n  // Fortunately, glob() with nocase case-corrects the input even if it is\n  // a *literal* path.\n  return glob.sync(noDrivePath, {\n    nocase: true,\n    cwd: pathRoot\n  })[0];\n}\nmodule.exports = trueCasePathSync;","map":{"version":3,"names":["glob","require","path","trueCasePathSync","fsPath","fsPathNormalized","normalize","process","platform","pathRoot","parse","root","noDrivePath","slice","Math","max","length","sync","nocase","cwd","module","exports"],"sources":["/home/manyaul/ReactProjects/board-game/node_modules/true-case-path/index.js"],"sourcesContent":["'use strict'\r\n\r\nvar glob = require('glob')\r\nvar path = require('path')\r\n\r\nfunction trueCasePathSync(fsPath) {\r\n\r\n  // Normalize the path so as to resolve . and .. components.\r\n  // !! As of Node v4.1.1, a path starting with ../ is NOT resolved relative\r\n  // !! to the current dir, and glob.sync() below then fails.\r\n  // !! When in doubt, resolve with fs.realPathSync() *beforehand*.\r\n  var fsPathNormalized = path.normalize(fsPath)\r\n\r\n  // OSX: HFS+ stores filenames in NFD (decomposed normal form) Unicode format,\r\n  // so we must ensure that the input path is in that format first.\r\n  if (process.platform === 'darwin') fsPathNormalized = fsPathNormalized.normalize('NFD')\r\n\r\n  // !! Windows: Curiously, the drive component mustn't be part of a glob,\r\n  // !! otherwise glob.sync() will invariably match nothing.\r\n  // !! Thus, we remove the drive component and instead pass it in as the 'cwd'\r\n  // !! (working dir.) property below.\r\n  var pathRoot = path.parse(fsPathNormalized).root\r\n  var noDrivePath = fsPathNormalized.slice(Math.max(pathRoot.length - 1, 0))\r\n\r\n  // Perform case-insensitive globbing (on Windows, relative to the drive /\r\n  // network share) and return the 1st match, if any.\r\n  // Fortunately, glob() with nocase case-corrects the input even if it is\r\n  // a *literal* path.\r\n  return glob.sync(noDrivePath, { nocase: true, cwd: pathRoot })[0]\r\n}\r\n\r\nmodule.exports = trueCasePathSync\r\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;AAC1B,IAAIC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;AAE1B,SAASE,gBAAgBA,CAACC,MAAM,EAAE;EAEhC;EACA;EACA;EACA;EACA,IAAIC,gBAAgB,GAAGH,IAAI,CAACI,SAAS,CAACF,MAAM,CAAC;;EAE7C;EACA;EACA,IAAIG,OAAO,CAACC,QAAQ,KAAK,QAAQ,EAAEH,gBAAgB,GAAGA,gBAAgB,CAACC,SAAS,CAAC,KAAK,CAAC;;EAEvF;EACA;EACA;EACA;EACA,IAAIG,QAAQ,GAAGP,IAAI,CAACQ,KAAK,CAACL,gBAAgB,CAAC,CAACM,IAAI;EAChD,IAAIC,WAAW,GAAGP,gBAAgB,CAACQ,KAAK,CAACC,IAAI,CAACC,GAAG,CAACN,QAAQ,CAACO,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;;EAE1E;EACA;EACA;EACA;EACA,OAAOhB,IAAI,CAACiB,IAAI,CAACL,WAAW,EAAE;IAAEM,MAAM,EAAE,IAAI;IAAEC,GAAG,EAAEV;EAAS,CAAC,CAAC,CAAC,CAAC,CAAC;AACnE;AAEAW,MAAM,CAACC,OAAO,GAAGlB,gBAAgB"},"metadata":{},"sourceType":"script","externalDependencies":[]}